<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Rationale</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Histogram">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Histogram">
<link rel="prev" href="benchmarks.html" title="Benchmarks">
<link rel="next" href="concepts.html" title="Concepts">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="benchmarks.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="concepts.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="histogram.rationale"></a><a class="link" href="rationale.html" title="Rationale">Rationale</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="rationale.html#histogram.rationale.philosophy_and_principles">Philosophy
      and principles</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.structure">Structure</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.histogram_types">Histograms types</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.axis_types">Axis types</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.storage_types">Storage types</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.uoflow">Under- and overflow bins</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.weights">Variance estimates</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.weigths">Support of weighted increments</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.python_support">Python support</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.serialization">Serialization</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.comparison_to_boost_accumulators">Comparison
      to Boost.Accumulators</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.philosophy_and_principles"></a><a class="link" href="rationale.html#histogram.rationale.philosophy_and_principles" title="Philosophy and principles">Philosophy
      and principles</a>
</h3></div></div></div>
<p>
        This library was written based on a decade of experience collected in working
        with big data, more precisely in the field of particle physics and astroparticle
        physics. The design is guided by advice from people like Bjarne Stroustrup,
        Scott Meyers, Herb Sutter, and Andrei Alexandrescu, and Chandler Carruth.
        I also like the <a href="https://www.python.org/dev/peps/pep-0020" target="_top">Zen
        of Python</a> (also applies to other languages). I also borrowed ideas
        from the <a href="https://eigen.tuxfamily.org/" target="_top">Eigen library</a>.
      </p>
<p>
        Two design goals of the library:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Provide the same interface for one-dimensional and multi-dimensional
            histograms. This makes the interface easier to learn, and makes it easier
            to move a project from one-dimensional to multi-dimensional analysis.
            This sounds obvious, but other libraries don't do that.
          </li>
<li class="listitem">
            Hide the details of how the bin counters work. Other implementations,
            notably those in the <a href="https://root.cern.ch" target="_top">ROOT framework</a>
            expose this, which forces the user to make a choice which is potentially
            dangerous. At best, the choice is merely inefficient. In the worst case,
            it can lead to information loss in form of overflowing or capped counters.
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.structure"></a><a class="link" href="rationale.html#histogram.rationale.structure" title="Structure">Structure</a>
</h3></div></div></div>
<p>
        The library consists of three orthogonal components:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a class="link" href="rationale.html#histogram.rationale.histogram_types" title="Histograms types">histogram types</a>:
            Host classes which defines the user interface and responsible for holding
            axis objects. The two variants have the same user interface, but differ
            internally.
          </li>
<li class="listitem">
            <a class="link" href="rationale.html#histogram.rationale.axis_types" title="Axis types">axis types</a>: Defines
            how input values are mapped to bins. Several axis types are provided
            which implement different specializations. The list is user-extensible.
          </li>
<li class="listitem">
            <a class="link" href="rationale.html#histogram.rationale.storage_types" title="Storage types">storage types</a>:
            Manages memory to hold bin counters. The requirements for a storage differ
            from those of an STL container. Two implementations are provided.
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.histogram_types"></a><a class="link" href="rationale.html#histogram.rationale.histogram_types" title="Histograms types">Histograms types</a>
</h3></div></div></div>
<p>
        Histograms store a number of axes. A one-dimensional histogram has one axis,
        a multi-dimensional histogram as several. Each axis maps a value from an
        input tuple onto a bin in its range.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          To understand the need for multi-dimensional histograms, think of point
          coordinates. If all points that you consider lie on a line, you need only
          one value to describe the point. If all points lie in a plane, you need
          two values to describe the position. Three values are needed for a point
          in space. A histogram puts a discrete grid over the line, the plane or
          the space, and counts how many points lie in each cell of the grid. To
          reflect a point distribution on a line, a 1d-histogram is sufficient. To
          do the same in 3d-space, one needs a 3d-histogram.
        </p></td></tr>
</table></div>
<p>
        This library supports different axis types, so that the user can customize
        how the mapping is done exactly, see <a class="link" href="rationale.html#histogram.rationale.axis_types" title="Axis types">axis
        types</a>. The number and concret types of the axes objects held by the
        histogram may be known at compile time or only at runtime, depending on how
        the library is used.
      </p>
<p>
        Users can chose between two histogram variants, which have the same user
        interface. The variant is selected with the first template argument of the
        histogram template, see <code class="computeroutput"><a class="link" href="../boost/histogram/histogram.html" title="Class template histogram">boost::histogram::histogram</a></code>.
        The static variant is faster (see <a class="link" href="benchmarks.html" title="Benchmarks">benchmark</a>),
        because it can hold the axis types directly and use static dispatch on them.
        This also means that user errors are caught at compile-time rather than run-time.
      </p>
<p>
        The static variant cannot be used when the user only knows the axis configuration
        at run-time, for example, if a histogram is created from Python. The dynamic
        variant addresses this and allows one to set the number of axes and their
        types at runtime. The interface of the dynamic variant is a strict superset
        of the static variant.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.axis_types"></a><a class="link" href="rationale.html#histogram.rationale.axis_types" title="Axis types">Axis types</a>
</h3></div></div></div>
<p>
        An axis defines which range of input values is mapped to which bin. The logic
        is encapsulated in an axis type. Users can create their own axis classes
        and use them with the library, by providing a class compatible with the
        <a class="link" href="concepts.html#histogram.concepts.axis" title="Axis type">axis concept</a>. The library
        comes with five builtin types, which implement different specializations.
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/axis/regular.html" title="Class template regular">boost::histogram::axis::regular</a></code>
            sorts real numbers into bins with equal width.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/axis/variable.html" title="Class template variable">boost::histogram::axis::variable</a></code>
            sorts real numbers into bins with varying width.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/axis/circular.html" title="Class template circular">boost::histogram::axis::circular</a></code>
            is a specialization of a regular axis for angles and similar values defined
            on a closed circle.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/axis/integer.html" title="Class template integer">boost::histogram::axis::integer</a></code>
            is a specialization of a regular axis for a range of integers with unit
            bin width.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/axis/category.html" title="Class template category">boost::histogram::axis::category</a></code>
            is a one-on-one mapping of a set of unique values onto bins. This can
            be used to count labels, like "red", "green", "blue".
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.storage_types"></a><a class="link" href="rationale.html#histogram.rationale.storage_types" title="Storage types">Storage types</a>
</h3></div></div></div>
<p>
        A storage type stores the actual bin counters. It uses a one-dimensional
        index for lookup, computed by the histogram host from the multi-dimensional
        index generated by evaluating all its axes. The storage therefore needs to
        know nothing about axes. Users can integrate their own storage classes with
        the library, by providing a class compatible with the <a class="link" href="concepts.html#histogram.concepts.storage" title="Storage type">storage
        concept</a>.
      </p>
<p>
        Dense (aka contiguous) storage in memory is needed for fast bin lookup, which
        is of the random-access variety, and may be happening in a tight loop. The
        builtin storage types therefore implement dense storage of bin counters.
        <code class="computeroutput"><a class="link" href="../boost/histogram/array_storage.html" title="Class template array_storage">boost::histogram::array_storage</a></code>
        implements a simple storage based on a heap-allocated array. That could be
        the end of story, but there are some issues with this approach. It is not
        convenient, because the user has to decide what (integral) type to use to
        hold the bin counts and it is not an obvious choice. The integer needs to
        be large enough to avoid counter overflow, but only a fraction of the bits
        are used if it is too large. Then it is a waste of memory. This is still
        a concern since the performance of modern CPUs requires frequent use of the
        CPU cache, which is small. Using floating point numbers is similarly dangerous.
        They don't overflow, but cap the bin count when the bits in the mantissa
        are used up.
      </p>
<p>
        The standard storage used in the library is <code class="computeroutput"><a class="link" href="../boost/histogram/adaptive_storage.html" title="Class adaptive_storage">boost::histogram::adaptive_storage</a></code>,
        which solves these issues with dynamic memory management, based on the following
        insight. The <a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality" target="_top">curse
        of dimensionality</a> makes the total number of bins grow very fast as
        the dimension of the histogram grows. However, having many bins also reduces
        the number of counts per bin, since the input values are spread over many
        more bins now.
      </p>
<p>
        We therefore start with a minimum amount of memory per bin counter by using
        the smallest integer type to hold a count. If the bin counter is about to
        overflow, we switch to the next larger integer type. We start with 1 byte
        per bin counter and then double the size as needed, until 8 byte per bin
        are reached. The following images illustrate this progression for a storage
        of 3 bin counters. Note, that always a new memory block is allocated for
        all counters, when one of them hits its capacity limit.
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../storage_3_uint8.svg" width="65" height="23"></object></span>
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../storage_3_uint16.svg" width="129" height="23"></object></span>
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../storage_3_uint32.svg" width="256" height="23"></object></span>
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../storage_3_uint64.svg" width="511" height="23"></object></span>
      </p>
<p>
        When even that is not enough, we switch to the <a href="../../../libs/multiprecision/index.html" target="_top">Boost.Multiprecision</a>
        type <code class="computeroutput"><span class="identifier">cpp_int</span></code>, whose capacity
        is limited only by available memory. The following image is not to scale:
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../storage_3_cpp_int.svg" width="511" height="23"></object></span>
      </p>
<p>
        This approach is not only memory conserving, but also ultimately safe, because
        bin counters cannot overflow.
      </p>
<p>
        And now comes the best part: this approach is even faster in the multi-dimensional
        case despite the overheads involved in handling the storage dynamically.
        The benchmarks show, that the gains from better cache usage outweigh the
        run-time overheads of dynamic dispatching to the right bin counter type and
        the additional allocation costs. Doubling the size of the bin counters each
        time helps, because then allocations happen only O(logN) times for N bin
        increments.
      </p>
<p>
        In a sense, <code class="computeroutput"><a class="link" href="../boost/histogram/adaptive_storage.html" title="Class adaptive_storage">adaptive_storage</a></code>
        is the opposite of a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>,
        which keeps the size of the stored type constant, but grows to hold a larger
        number of elements. Here, the number of elements remains the same, but the
        storage grows to hold a uniform collection of larger and larger elements.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.uoflow"></a><a class="link" href="rationale.html#histogram.rationale.uoflow" title="Under- and overflow bins">Under- and overflow bins</a>
</h3></div></div></div>
<p>
        Axis instances by default add extra bins that count values which fall below
        or above the range covered by the axis (for those types where that makes
        sense). These extra bins are called under- and overflow bins, respectively.
        The extra bins can be turned off individually for each axis to conserve memory,
        but it generally recommended to keep them. The extra bins do not interfere
        with normal bin counting. On an axis with <code class="computeroutput"><span class="identifier">n</span></code>
        bins, the first bin has the index <code class="computeroutput"><span class="number">0</span></code>,
        the last bin <code class="computeroutput"><span class="identifier">n</span><span class="special">-</span><span class="number">1</span></code>, while the under- and overflow bins are accessible
        at the indices <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>
        and <code class="computeroutput"><span class="identifier">n</span></code>, respectively.
      </p>
<p>
        Under- and overflow bins are useful in one-dimensional histograms, and nearly
        essential in multi-dimensional histograms. Here are the advantages:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            No loss: The total sum over all bin counts is strictly equal to the number
            of times <code class="computeroutput"><span class="identifier">fill</span><span class="special">(...)</span></code>
            was called. Even NaN values are counted, they end up in the underflow
            bin by convention.
          </li>
<li class="listitem">
            Diagnosis: Unexpected extreme values show up in the extra bins, which
            otherwise may be overlooked.
          </li>
<li class="listitem">
            Reducability: In multi-dimensional histograms, an out-of-range value
            along one axis may be paired with an in-range value along another axis.
            If under- and overflow bins are missing, such a value pair is lost completely.
            If you apply a <code class="computeroutput"><span class="identifier">reduce</span></code>
            operation on a histogram, which removes somes axes by resummation of
            the bin counts, this would lead to distortions the histogram even along
            the remaining axes. When under- and overflow bins are present, the <code class="computeroutput"><span class="identifier">reduce</span></code> operation always produces the
            same sub-histogram that would have been obtained if it was filled from
            scratch with the original data.
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.weights"></a><a class="link" href="rationale.html#histogram.rationale.weights" title="Variance estimates">Variance estimates</a>
</h3></div></div></div>
<p>
        Once a histogram is filled, the count <span class="emphasis"><em>k</em></span> in a bin can
        be queried with the <code class="computeroutput"><span class="identifier">value</span><span class="special">(...)</span></code> method. The histogram also offers a
        <code class="computeroutput"><span class="identifier">variance</span><span class="special">(...)</span></code>
        method, which returns an estimate of the <a href="https://en.wikipedia.org/wiki/Variance" target="_top">variance</a>
        <span class="emphasis"><em>v</em></span> of that count.
      </p>
<p>
        If the input values for the histogram come from a <a href="https://en.wikipedia.org/wiki/Stochastic_process" target="_top">stochastic
        process</a>, the variance provides useful additional information. Examples
        for a stochastic process are a physics experiment or a random person filling
        out a questionaire<a href="#ftn.histogram.rationale.weights.f0" class="footnote" name="histogram.rationale.weights.f0"><sup class="footnote">[2]</sup></a>. The variance <span class="emphasis"><em>v</em></span> is the square of the <a href="https://en.wikipedia.org/wiki/Standard_deviation" target="_top">standard deviation</a>.
        The standard deviation in a bin tells us how much we can expect the observed
        value to fluctuate if we or someone else would repeat our experiment with
        new random input.
      </p>
<p>
        Variance estimates are useful in many ways:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Error bars: Drawing an <a href="https://en.wikipedia.org/wiki/Error_bar" target="_top">error
            bar</a> over the interval <span class="emphasis"><em>(k - sqrt(v), k + sqrt(v))</em></span>
            is a simple visualisation of the expected random scatter of the bin value
            <span class="emphasis"><em>k</em></span>, if the histogram was cleared and filled again
            with another independent sample of the same size (e.g. by repeating the
            physics experiment or asking more people to fill a questionaire). If
            you compare the result with a fitted model (see next item), about 2/3
            of the error bars should overlap with the model, if the model is correct.
          </li>
<li class="listitem">
            Least-squares fitting: Often you have a model of the expected number
            of counts <span class="emphasis"><em>lambda</em></span> per bin, which is a function of
            parameters with unknown values. A simple method to find good (sometimes
            the best) estimates for those parameter values is to vary them until
            the sum of squared residuals <span class="emphasis"><em>(k - lambda)^2/v</em></span> is
            minimized. This is the <a href="https://en.wikipedia.org/wiki/Least_squares" target="_top">method
            of least squares</a>, in which both the bin values <span class="emphasis"><em>k</em></span>
            and variance estimates <span class="emphasis"><em>v</em></span> enter.
          </li>
<li class="listitem">
            Pull distributions: If you have two histograms filled with the same number
            of samples and you want to know whether they are in agreement, you can
            compare the so-called pull distribution. It is formed by subtracting
            the counts and dividing by the square root of their variances <span class="emphasis"><em>(k1
            - k2)/sqrt(v1 + v2)</em></span>. If the histograms are identical, the
            pull distribution randomly scatters around zero, and about 2/3 of the
            values are in the interval <span class="emphasis"><em>[ -1, 1]</em></span>.
          </li>
</ul></div>
<p>
        Why return the variance <span class="emphasis"><em>v</em></span> and not the standard deviation
        <span class="emphasis"><em>s = sqrt(v)</em></span>? The reason is the additivity of variances.
        <a href="https://en.wikipedia.org/wiki/Variance#Properties" target="_top">Variances
        of independent samples can be added</a> like normal numbers <span class="emphasis"><em>v3
        = v1 + v2</em></span>. This is not true for standard deviations, where the
        addition law is more complex <span class="emphasis"><em>s3 = sqrt(s1^2 + s2^2)</em></span>.
        In that sense, the variance is more straight-forward to use during data processing.
        It is also obviously more efficient. The user can take the square-root at
        the end of the processing obtain the standard deviation as needed.
      </p>
<p>
        How is the variance estimate <span class="emphasis"><em>v</em></span> computed? If we know
        the expected number of counts <span class="emphasis"><em>lambda</em></span> per bin, we could
        compute the variance as <span class="emphasis"><em>v = lambda</em></span>, because counts in
        a histogram follow the <a href="https://en.wikipedia.org/wiki/Poisson_distribution" target="_top">Poisson
        distribution</a> <a href="#ftn.histogram.rationale.weights.f1" class="footnote" name="histogram.rationale.weights.f1"><sup class="footnote">[3]</sup></a>. After filling a histogram, we do not know the expected number
        of counts <span class="emphasis"><em>lambda</em></span> for any particular bin, but we know
        the observed count <span class="emphasis"><em>k</em></span>, which is not too far from <span class="emphasis"><em>lambda</em></span>.
        We therefore might be tempted to just replace <span class="emphasis"><em>lambda</em></span>
        with <span class="emphasis"><em>k</em></span> in the formula <span class="emphasis"><em>v = lambda = k</em></span>.
        This is in fact the so-called non-parameteric estimate for the variance based
        on the <a href="https://en.wikipedia.org/wiki/Plug-in_principle" target="_top">plug-in
        principle</a>. It is the best (and only) estimate for the variance, if
        we know nothing more about the underlying stochastic process which generated
        the inputs (or want to feign ignorance about it).
      </p>
<p>
        Now, if the value returned by the method <code class="computeroutput"><span class="identifier">variance</span><span class="special">(...)</span></code> is just the same as the value return
        by <code class="computeroutput"><span class="identifier">value</span><span class="special">(...)</span></code>,
        why bother with adding a <code class="computeroutput"><span class="identifier">variance</span><span class="special">(...)</span></code> method, except perhaps for convenience?
        There is another reason, which becomes apparent if the histograms are filled
        with weighted counts, which is discussed next.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.weigths"></a><a class="link" href="rationale.html#histogram.rationale.weigths" title="Support of weighted increments">Support of weighted increments</a>
</h3></div></div></div>
<p>
        A histogram categorizes input values and increments a bin counter if an input
        value falls into the value range covered by that bin. The <code class="computeroutput"><a class="link" href="../boost/histogram/adaptive_storage.html" title="Class adaptive_storage">standard
        storage</a></code> uses integer types to store these counts, see the <a class="link" href="rationale.html#histogram.rationale.storage_types" title="Storage types">storage section</a> how integer
        overflow is avoided. However, sometimes histograms need to be filled with
        values that have a weight <span class="emphasis"><em>w</em></span> attached to them. In this
        case, the corresponding bin counter is not increased by one, but by the passed
        weight <span class="emphasis"><em>w</em></span>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          There are several uses for weighted increments. The main use in particle
          physics is to adapt simulated data of an experiment to real data. Simulations
          are needed to determine various corrections and efficiencies, but a simulated
          experiment is almost never a perfect replica of the real experiment. In
          addition, simulations are expensive to do. So, when deviations in a simulated
          distribution of a variable are found, one typically does not rerun the
          simulations, but assigns weights to match the simulated distribution to
          the real one.
        </p></td></tr>
</table></div>
<p>
        When the <code class="computeroutput"><a class="link" href="../boost/histogram/adaptive_storage.html" title="Class adaptive_storage">adaptive_storage</a></code>
        is used, histograms may also be filled with weighted value tuples. The choice
        of using weighted fills can be made at run-time. If the call <code class="computeroutput"><span class="identifier">fill</span><span class="special">(...,</span> <span class="identifier">weight</span><span class="special">(</span><span class="identifier">x</span><span class="special">))</span></code> is
        used, two doubles per bin are stored (previous integer counts are automatically
        converted). The first double keeps track of the sum of weights. The second
        double keeps track of the sum of weights squared. The latter is the variance
        estimate in this case and returned by a call to <code class="computeroutput"><span class="identifier">variance</span><span class="special">(...)</span></code>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          This variance estimate can be derived from the <a href="https://en.wikipedia.org/wiki/Variance#Properties" target="_top">mathematical
          properties of the variance</a>. Let us say a bin is filled <span class="emphasis"><em>k1</em></span>
          times with weight <span class="emphasis"><em>w1</em></span>. The sum of weights is then
          <span class="emphasis"><em>w1 k1</em></span>. It then follows from the variance properties
          that <span class="emphasis"><em>Var(w1 k1) = w1^2 Var(k1)</em></span>. Using the reasoning
          from before, the estimated variance of <span class="emphasis"><em>k1</em></span> is <span class="emphasis"><em>k1</em></span>,
          so that <span class="emphasis"><em>Var(w1 k1) = w1^2 Var(k1) = w1^2 k1</em></span>. Variances
          of independent samples are additive. If the bin is further filled <span class="emphasis"><em>k2</em></span>
          times with weight <span class="emphasis"><em>w2</em></span>, the sum of weights is <span class="emphasis"><em>w1
          k1 + w2 k2</em></span>, with variance <span class="emphasis"><em>w1^2 k1 + w2^2 k2</em></span>.
          This also holds for <span class="emphasis"><em>k1 = k2 = 1</em></span>. Therefore, the sum
          of weights <span class="emphasis"><em>w[i]</em></span> has variance sum of <span class="emphasis"><em>w[i]^2</em></span>.
          In other words, to incrementally keep track of the variance of the sum
          of weights, we need to keep track of the sum of weights squared.
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.python_support"></a><a class="link" href="rationale.html#histogram.rationale.python_support" title="Python support">Python support</a>
</h3></div></div></div>
<p>
        Python is a popular scripting language in the data science community. Thus,
        the library provides Python bindings. The histogram may be used as an interface
        between a complex simulation or data-storage system written in C++ and data-analysis/plotting
        in Python. Users are able to define the histogram in Python, let it be filled
        on the C++ side (using a few lines of Boost.Python code to define the interface),
        and then get it back for further data analysis or plotting.
      </p>
<p>
        Data analysis in Python is Numpy-based, so Numpy is fully support. Histograms
        can be filled with chunks of data in form of Numpy arrays, which is efficient,
        and the bin counts can be retrieved as a Numpy array without copying data.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          If number of dimensions is larger than one, this implementation is faster
          than the equivalent Numpy functions (while being more flexible), see <a class="link" href="benchmarks.html" title="Benchmarks">benchmark</a>.
        </p></td></tr>
</table></div>
<p>
        The Python and C++ interface were designed to be as consistent as possible,
        while following established style for the respective C++ or Python community.
        This leads to the following stylistic changes on the Python side.
      </p>
<p>
        Properties: Getter/setter-like functions on the C++ side are wrapped in Python
        as properties. Examples: <code class="computeroutput"><span class="identifier">histogram</span><span class="special">.</span><span class="identifier">dim</span></code>,
        <code class="computeroutput"><span class="identifier">axis</span><span class="special">.</span><span class="identifier">regular</span><span class="special">.</span><span class="identifier">uoflow</span></code>. In general, a C++ function that
        takes no argument but returns a value is using the property syntax on the
        Python side. An exception is made for the function <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>, see next item.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">len</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span></code> versus
        <code class="computeroutput"><span class="identifier">x</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span></code>:
        An axis instance behaves like a container of bins in C++ and like a sequence
        of bins in Python. To get the length of a sequence in Python one uses the
        <code class="computeroutput"><span class="identifier">len</span><span class="special">(...)</span></code>
        function, while in C++ one uses the <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code> method.
      </p>
<p>
        Keyword-based parameters: the member function call <code class="computeroutput"><span class="identifier">fill</span><span class="special">(...,</span> <span class="identifier">weight</span><span class="special">(</span><span class="identifier">x</span><span class="special">))</span></code>
        in C++ is translated into a Python member function call <code class="computeroutput"><span class="identifier">fill</span><span class="special">(...,</span> <span class="identifier">weight</span><span class="special">=</span><span class="identifier">x</span><span class="special">)</span></code>.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.serialization"></a><a class="link" href="rationale.html#histogram.rationale.serialization" title="Serialization">Serialization</a>
</h3></div></div></div>
<p>
        Serialization is implemented using <a href="../../../libs/serialization/index.html" target="_top">Boost.Serialization</a>.
        Pickling in Python is implemented based on the C++ serialization code. In
        the current implementation, the pickled stream is <span class="bold"><strong>not</strong></span>
        portable between different hardware platforms, since it uses <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">archive</span><span class="special">::</span><span class="identifier">binary_archive</span></code>. It would be great to switch
        to a portable binary representation in the future, when that becomes available.
        In practice, most computing clusters and most consumer hardware are x86 compatible
        nowadays. The binary_archive is portable between such hardware platforms.
        Naturally, it is portable between operating systems, like OSX, Windows, and
        Linux.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.comparison_to_boost_accumulators"></a><a class="link" href="rationale.html#histogram.rationale.comparison_to_boost_accumulators" title="Comparison to Boost.Accumulators">Comparison
      to Boost.Accumulators</a>
</h3></div></div></div>
<p>
        Boost.Histogram has a weak overlap with <a href="../../../libs/accumulators/index.html" target="_top">Boost.Accumulators</a>.
        In particular, the statistical accumulators <code class="computeroutput"><span class="identifier">density</span></code>
        and <code class="computeroutput"><span class="identifier">weighted_density</span></code> also
        generate one-dimensional histograms. The axis range and the bin widths are
        determined automatically from a cached sample of initial values. In contrast,
        Boost.Histogram puts the responsibility to choose range and bin widths on
        the user.
      </p>
<p>
        Automatic binning is not an option for Boost.Histogram, because it does not
        scale well to many dimensions. Because of the Curse of Dimensionality, a
        prohibitive number of samples would need to be collected.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          There is no scientific consensus on how do automatic binning in an optimal
          way, mostly because there is no consensus over the cost function (there
          are many articles with different solutions in the literature). The problem
          is not solved for one-dimensional data, and even less so for multi-dimensional
          data.
        </p></td></tr>
</table></div>
<p>
        Recommendation:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Boost.Accumulators
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
                  You have one-dimensional data of which you know nothing about,
                  and you want a histogram quickly without worrying about binning
                  details.
                </li></ul></div>
          </li>
<li class="listitem">
            Boost.Histogram
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                  You have multi-dimensional data or you suspect you will switch
                  to multi-dimensional data later.
                </li>
<li class="listitem">
                  You want to customize the binning by hand, for example, to make
                  bin edges coincide with special values or to handle special properties
                  of your values, like angles defined on a circle.
                </li>
</ul></div>
          </li>
</ul></div>
</div>
<div class="footnotes">
<br><hr style="width:100; text-align:left;margin-left: 0">
<div id="ftn.histogram.rationale.weights.f0" class="footnote"><p><a href="#histogram.rationale.weights.f0" class="para"><sup class="para">[2] </sup></a>
          The choices of the person are most likely not random, but if we pick a
          random person from a group, we randomly sample from a pool of opinions
        </p></div>
<div id="ftn.histogram.rationale.weights.f1" class="footnote"><p><a href="#histogram.rationale.weights.f1" class="para"><sup class="para">[3] </sup></a>
          The Poisson distribution is correct as far as the counts <span class="emphasis"><em>k</em></span>
          themselves are of interest. If the fractions per bin <span class="emphasis"><em>p = k /
          N</em></span> are of interest, where <span class="emphasis"><em>N</em></span> is the total
          number of counts, then the correct distribution to describe the fractions
          is the <a href="https://en.wikipedia.org/wiki/Multinomial_distribution" target="_top">multinomial
          distribution</a>.
        </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016, 2017 Hans Dembinski<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="benchmarks.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="concepts.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
